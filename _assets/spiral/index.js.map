{
  "version": 3,
  "sources": ["../../../../packages/runtime/dist/esm/context-2eb14bc3.js", "../../../../packages/runtime/dist/esm/internal.js", "../../../src/spiral/components/Cursor.velvet", "../../../src/spiral/components/Spiral.velvet", "../../../../node_modules/.pnpm/perf-monitor@0.4.1/node_modules/perf-monitor/dist/es5/perf-monitor.js", "../../../src/spiral/index.js"],
  "sourcesContent": ["function html(fragment, is_wrapped) {\n  let node = document.createElement(\"template\");\n  node.innerHTML = fragment;\n  if (is_wrapped) {\n    let content = node.content;\n    let wrapper = content.childNodes[0];\n    let children = wrapper.childNodes;\n    let len = children.length;\n    wrapper.remove();\n    while (len--) {\n      content.appendChild(children[0]);\n    }\n  }\n  return node;\n}\nfunction create(element) {\n  return document.createElement(element);\n}\nfunction clone(template) {\n  let fragment = document.importNode(template.content, true);\n  return fragment;\n}\nfunction traverse(node, indices) {\n  let ref = node;\n  let i = 0;\n  let il = indices.length;\n  let x;\n  let j;\n  for (; i < il; i++) {\n    x = indices[i];\n    ref = ref.firstChild;\n    for (j = 0; j < x; j++) {\n      ref = ref.nextSibling;\n    }\n  }\n  return ref;\n}\nfunction replace(ref, node, adopt) {\n  ref.replaceWith(node);\n  if (adopt) {\n    let children = ref.childNodes;\n    let len = children.length;\n    while (len--) {\n      node.appendChild(children[0]);\n    }\n  }\n}\nfunction append(ref, node) {\n  ref.append(node);\n}\nfunction after(ref, node) {\n  ref.after(node);\n}\nfunction remove_parts(a, b) {\n  let node = a;\n  if (b.nextSibling === a) {\n    return;\n  }\n  while (node) {\n    let curr = node;\n    node = node.nextSibling;\n    curr.remove();\n    if (curr === b) {\n      break;\n    }\n  }\n}\nfunction on(node, type, listener, options) {\n  node.addEventListener(type, listener, options);\n}\nfunction toggle(node, name, value) {\n  node.toggleAttribute(name, value);\n}\nfunction attr(node, name, value) {\n  node.setAttribute(name, value);\n}\nfunction attr_ifdef(node, name, value) {\n  let map = node.$ifd || (node.$ifd = {});\n  let def = value != null;\n  if (def) {\n    attr(node, name, value);\n  } else if (map[name]) {\n    node.removeAttribute(name);\n  }\n  map[name] = def;\n}\nfunction class_toggle(node, name, value) {\n  node.classList.toggle(name, value);\n}\nfunction style_set(node, name, value) {\n  node.style.setProperty(name, value);\n}\nfunction get_checked_values(array, value, checked) {\n  let next = array.slice();\n  if (checked) {\n    next.push(value);\n    return next;\n  } else {\n    let index = array.indexOf(value);\n    if (index > -1) {\n      next.splice(index, 1);\n      return next;\n    }\n  }\n  return array;\n}\nfunction get_select_values(select) {\n  let multiple = select.multiple;\n  let array = [];\n  let selected = select.selectedOptions;\n  for (let i = 0, l = selected.length; i < l; i++) {\n    let option = selected[i];\n    array.push(option.value);\n  }\n  return multiple ? array : array[0];\n}\nfunction set_select_values(select, current) {\n  let multiple = select.multiple;\n  let options = select.options;\n  for (let i = 0, l = options.length; i < l; i++) {\n    let option = options[i];\n    let selected = multiple ? current.includes(option.value) : option.value === current;\n    option.selected = selected;\n    if (selected && !multiple) {\n      return;\n    }\n  }\n}\n\nlet _Object = Object;\nlet _Symbol = Symbol;\n\nlet RE_HYPHENATE = /\\B([A-Z])/g;\nlet noop = () => {\n};\nfunction hyphenate(str) {\n  return str.replace(RE_HYPHENATE, \"-$1\").toLowerCase();\n}\nlet is = _Object.is;\nlet assign = _Object.assign;\nlet is_function = (x) => typeof x === \"function\";\nfunction to_number(value) {\n  return value === \"\" ? null : +value;\n}\n\nlet undefined$1;\nlet RUNNING = 1 << 0;\nlet STALE = 1 << 1;\nlet NOTIFIED = 1 << 2;\nlet HAS_ERROR = 1 << 3;\nlet SHOULD_SUBSCRIBE = 1 << 4;\nlet SUBSCRIBED = 1 << 5;\nlet eval_scope;\nlet eval_context;\nlet batched_effects;\nlet batch_depth = 0;\nlet batch_iteration = 0;\nlet global_version = 0;\nfunction start_batch() {\n  batch_depth++;\n}\nfunction end_batch() {\n  if (batch_depth > 1) {\n    batch_depth--;\n    return;\n  }\n  let error;\n  let has_error = false;\n  while (batched_effects) {\n    let effects = batched_effects.sort((a, b) => a.h - b.h);\n    batched_effects = undefined$1;\n    batch_iteration++;\n    for (let i = 0, l = effects.length; i < l; i++) {\n      let effect2 = effects[i];\n      effect2.c &= ~NOTIFIED;\n      try {\n        effect2.s();\n      } catch (err) {\n        if (!has_error) {\n          error = err;\n          has_error = true;\n        }\n      }\n    }\n  }\n  batch_iteration = 0;\n  batch_depth--;\n  if (has_error) {\n    throw error;\n  }\n}\nfunction get_value(signal2) {\n  let node;\n  if (eval_context) {\n    node = signal2.k;\n    if (!node || node.p !== eval_context) {\n      node = {\n        d: 0,\n        c: 0,\n        m: undefined$1,\n        g: signal2,\n        e: eval_context.b,\n        i: undefined$1,\n        p: eval_context,\n        j: undefined$1,\n        n: undefined$1\n      };\n      eval_context.b = node;\n      signal2.k = node;\n      if (eval_context.c & SHOULD_SUBSCRIBE) {\n        signal2.o(node);\n      }\n    } else if (node.c & STALE) {\n      node.c &= ~STALE;\n      let head = eval_context.b;\n      let prev = node.i;\n      let next = node.e;\n      if (node !== head) {\n        if (prev) {\n          prev.e = next;\n        }\n        if (next) {\n          next.i = prev;\n        }\n        if (head) {\n          head.i = node;\n        }\n        node.i = undefined$1;\n        node.e = head;\n        eval_context.b = node;\n      }\n    } else {\n      node = undefined$1;\n    }\n  }\n  try {\n    return signal2.peek();\n  } finally {\n    if (node) {\n      node.d = signal2.d;\n    }\n  }\n}\nfunction get_computed(computed2) {\n  computed2.c &= ~RUNNING;\n  if (computed2.c & HAS_ERROR) {\n    throw computed2.a;\n  }\n  return computed2.a;\n}\nfunction prepare_sources(target) {\n  for (let node = target.b; node; node = node.e) {\n    let rollback = node.g.k;\n    if (rollback) {\n      node.m = rollback;\n    }\n    node.g.k = node;\n    node.c |= STALE;\n  }\n}\nfunction cleanup_sources(target) {\n  let node = target.b;\n  let sources;\n  while (node) {\n    let next = node.e;\n    if (node.c & STALE) {\n      node.g.l(node);\n      node.e = undefined$1;\n    } else {\n      if (sources) {\n        sources.i = node;\n      }\n      node.i = undefined$1;\n      node.e = sources;\n      sources = node;\n    }\n    node.g.k = node.m;\n    if (node.m) {\n      node.m = undefined$1;\n    }\n    node = next;\n  }\n  target.b = sources;\n}\nfunction end_effect(prev_context) {\n  let _this = this;\n  cleanup_sources(_this);\n  eval_context = prev_context;\n  end_batch();\n  _this.c &= ~RUNNING;\n}\nclass Signal {\n  constructor(value) {\n    let _this = this;\n    _this.d = 0;\n    _this.a = value;\n    _this.k = undefined$1;\n    _this.f = undefined$1;\n  }\n  o(node) {\n    let _this = this;\n    if (!(node.c & SUBSCRIBED)) {\n      node.c |= SUBSCRIBED;\n      node.j = _this.f;\n      if (_this.f) {\n        _this.f.n = node;\n      }\n      _this.f = node;\n    }\n  }\n  l(node) {\n    let _this = this;\n    let prev = node.n;\n    let next = node.j;\n    if (node.c & SUBSCRIBED) {\n      node.c &= ~SUBSCRIBED;\n      if (prev) {\n        prev.j = next;\n        node.n = undefined$1;\n      }\n      if (next) {\n        next.n = prev;\n        node.j = undefined$1;\n      }\n      if (node === _this.f) {\n        _this.f = next;\n      }\n    }\n  }\n  subscribe(fn) {\n    let signal2 = this;\n    return effect(function() {\n      let value = signal2.value;\n      let prev_context = eval_context;\n      eval_context = undefined$1;\n      try {\n        return fn(value);\n      } finally {\n        eval_context = prev_context;\n      }\n    });\n  }\n  set(next) {\n    return this.value = next;\n  }\n  peek() {\n    return this.a;\n  }\n  get value() {\n    return get_value(this);\n  }\n  set value(value) {\n    let _this = this;\n    if (value !== _this.a) {\n      _this.a = value;\n      if (batch_iteration > 100) {\n        return;\n      }\n      _this.d++;\n      global_version++;\n      start_batch();\n      try {\n        for (let node = _this.f; node; node = node.j) {\n          node.p.q();\n        }\n      } finally {\n        end_batch();\n      }\n    }\n  }\n}\nclass Computed extends Signal {\n  constructor(compute) {\n    super(undefined$1);\n    this.r = compute;\n    this.b = undefined$1;\n    this.c = STALE;\n    this.t = global_version - 1;\n  }\n  o(node) {\n    let _this = this;\n    if (!_this.f) {\n      _this.c |= STALE | SHOULD_SUBSCRIBE;\n      for (let node2 = _this.b; node2; node2 = node2.e) {\n        node2.g.o(node2);\n      }\n    }\n    super.o(node);\n  }\n  l(node) {\n    let _this = this;\n    super.l(node);\n    if (!_this.f) {\n      _this.c &= ~SHOULD_SUBSCRIBE;\n      for (let node2 = _this.b; node2; node2 = node2.e) {\n        node2.g.l(node2);\n      }\n    }\n  }\n  q() {\n    let _this = this;\n    if (!(_this.c & (NOTIFIED | RUNNING))) {\n      _this.c |= STALE | NOTIFIED;\n      for (let node = _this.f; node; node = node.j) {\n        node.p.q();\n      }\n    }\n  }\n  peek() {\n    let _this = this;\n    _this.c &= ~NOTIFIED;\n    if (_this.c & RUNNING) {\n      return _this.a;\n    }\n    _this.c |= RUNNING;\n    if (!(_this.c & STALE) && _this.f || _this.t === global_version) {\n      return get_computed(_this);\n    }\n    _this.c &= ~STALE;\n    _this.t = global_version;\n    if (_this.d > 0) {\n      let node = _this.b;\n      while (node) {\n        if (node.g.d !== node.d) {\n          break;\n        }\n        try {\n          node.g.peek();\n        } catch {\n        }\n        if (node.g.d !== node.d) {\n          break;\n        }\n        node = node.e;\n      }\n      if (!node) {\n        return get_computed(_this);\n      }\n    }\n    let prev_value = _this.a;\n    let prev_flags = _this.c;\n    let prev_context = eval_context;\n    try {\n      eval_context = _this;\n      prepare_sources(_this);\n      _this.a = _this.r();\n      _this.c &= ~HAS_ERROR;\n      if (prev_flags & HAS_ERROR || _this.a !== prev_value || _this.d === 0) {\n        _this.d++;\n      }\n    } catch (err) {\n      _this.a = err;\n      _this.c |= HAS_ERROR;\n      _this.d++;\n    } finally {\n      cleanup_sources(_this);\n      eval_context = prev_context;\n    }\n    return get_computed(_this);\n  }\n  get value() {\n    let _this = this;\n    if (_this.c & RUNNING) {\n      return _this.a;\n    }\n    return get_value(_this);\n  }\n  set value(next) {\n    super.value = next;\n  }\n}\nclass Effect {\n  constructor(compute) {\n    this.r = compute;\n    this.b = undefined$1;\n    this.h = 0;\n    this.c = SHOULD_SUBSCRIBE;\n  }\n  s() {\n    let _this = this;\n    if (_this.c & RUNNING) {\n      return;\n    }\n    let finish = _this.u();\n    try {\n      _this.r();\n    } finally {\n      finish();\n    }\n  }\n  u() {\n    let _this = this;\n    let prev_context = eval_context;\n    _this.c |= RUNNING;\n    start_batch();\n    eval_context = _this;\n    prepare_sources(_this);\n    return end_effect.bind(_this, prev_context);\n  }\n  q() {\n    let _this = this;\n    if (!(_this.c & (NOTIFIED | RUNNING))) {\n      _this.c |= NOTIFIED;\n      if (!batched_effects) {\n        batched_effects = [];\n      }\n      batched_effects.push(_this);\n    }\n  }\n  v() {\n    let _this = this;\n    for (let node = _this.b; node; node = node.e) {\n      node.g.l(node);\n    }\n    _this.c |= RUNNING;\n    _this.b = undefined$1;\n  }\n}\nclass Scope {\n  constructor(detached) {\n    let _this = this;\n    _this.scopes = [];\n    _this.cleanups = [];\n    _this.parent = undefined$1;\n    _this.h = 0;\n    if (!detached && eval_scope) {\n      _this.parent = eval_scope;\n      _this.h = eval_scope.h + 1;\n      eval_scope.scopes.push(_this);\n    }\n  }\n  run(callback) {\n    let prev_scope = eval_scope;\n    try {\n      eval_scope = this;\n      return callback();\n    } finally {\n      eval_scope = prev_scope;\n    }\n  }\n  clear() {\n    let _this = this;\n    let scopes = _this.scopes;\n    let cleanups = _this.cleanups;\n    for (let scope2 of scopes) {\n      scope2.clear();\n      scope2.parent = undefined$1;\n    }\n    for (let cleanup2 of cleanups) {\n      cleanup2();\n    }\n    scopes.length = 0;\n    cleanups.length = 0;\n  }\n}\nfunction scope(detached) {\n  return new Scope(detached);\n}\nfunction cleanup(callback) {\n  if (is_function(callback) && eval_scope) {\n    eval_scope.cleanups.push(callback);\n  }\n}\nfunction batch(callback) {\n  if (batch_depth > 0) {\n    return callback();\n  }\n  start_batch();\n  try {\n    return callback();\n  } finally {\n    end_batch();\n  }\n}\nfunction untrack(callback) {\n  let prev_context = eval_context;\n  try {\n    eval_context = undefined$1;\n    return callback();\n  } finally {\n    eval_context = prev_context;\n  }\n}\nfunction peek(value) {\n  if (value instanceof Signal) {\n    return value.peek();\n  }\n  return value;\n}\nfunction signal(value) {\n  return new Signal(value);\n}\nfunction computed(compute) {\n  return new Computed(compute);\n}\nfunction effect(compute) {\n  let effect2 = new Effect(compute);\n  let dispose = effect2.v.bind(effect2);\n  try {\n    effect2.s();\n  } catch (error) {\n    dispose();\n    throw error;\n  }\n  if (eval_scope && effect2.b) {\n    effect2.h = eval_scope.h;\n    eval_scope.cleanups.push(dispose);\n  }\n  return dispose;\n}\n\nlet ENABLE_RANDOM_TAGS = false;\nlet RANDOM_TAG = 1;\nfunction use_random_tags() {\n  ENABLE_RANDOM_TAGS = true;\n}\nlet curr_host = null;\nlet default_value = _Symbol();\nclass VelvetComponent extends HTMLElement {\n  $m = false;\n  $c = scope(true);\n  $p = {};\n  $h = [];\n  constructor() {\n    super();\n    let host = this;\n    let props = host.$p;\n    let definition = host.constructor.$d;\n    for (let prop2 in definition) {\n      let index = definition[prop2];\n      props[index] = signal(default_value);\n    }\n  }\n  connectedCallback() {\n    let host = this;\n    if (!host.$m) {\n      host.$m = true;\n      let setup = host.constructor.$c;\n      let styles = host.constructor.$s;\n      let instance = host.$c;\n      let hooks = host.$h;\n      let root = host.shadowRoot;\n      let init_ccss = false;\n      if (!root) {\n        root = host.attachShadow({ mode: \"open\" });\n        init_ccss = true;\n      }\n      let prev_host = curr_host;\n      try {\n        curr_host = host;\n        instance.run(() => setup(root, host));\n        if (document.adoptedStyleSheets) {\n          if (init_ccss) {\n            root.adoptedStyleSheets = styles;\n          }\n        } else {\n          for (let style of styles) {\n            append(root, style.cloneNode(true));\n          }\n        }\n        for (let hook of hooks) {\n          let ret = hook();\n          if (is_function(ret)) {\n            instance.cleanups.push(ret);\n          }\n        }\n        hooks.length = 0;\n      } finally {\n        curr_host = prev_host;\n      }\n    }\n  }\n  disconnectedCallback() {\n    let host = this;\n    if (host.$m) {\n      host.$c.clear();\n      host.shadowRoot.innerHTML = \"\";\n      host.$m = false;\n    }\n  }\n  attributeChangedCallback(attr, prev, next) {\n    let host = this;\n    let mapping = host.constructor.$d;\n    if (attr in mapping) {\n      host.$p[mapping[attr]].value = next === \"\" ? true : next;\n    }\n  }\n}\nfunction define(tag, setup, definition, styles) {\n  let observed_attrs = [];\n  let attr_to_prop = _Object.create(null);\n  class Component extends VelvetComponent {\n    static observedAttributes = observed_attrs;\n    static $c = setup;\n    static $a = attr_to_prop;\n    static $d = definition;\n    static $s = styles;\n  }\n  for (let prop2 in definition) {\n    let index = definition[prop2];\n    let hyphen = hyphenate(prop2);\n    attr_to_prop[hyphen] = prop2;\n    observed_attrs.push(hyphen);\n    _Object.defineProperty(Component.prototype, prop2, {\n      get() {\n        return this.$p[index].a;\n      },\n      set(next) {\n        this.$p[index].value = next;\n      }\n    });\n  }\n  if (ENABLE_RANDOM_TAGS) {\n    tag = \"velvet-\" + RANDOM_TAG++;\n  }\n  if (tag) {\n    customElements.define(tag, Component);\n  }\n  return Component;\n}\nfunction css(text) {\n  if (!document.adoptedStyleSheets) {\n    const style2 = document.createElement(\"style\");\n    style2.textContent = text;\n    return style2;\n  }\n  const style = new CSSStyleSheet();\n  style.replaceSync(text);\n  return style;\n}\nfunction prop(index, value) {\n  let state = curr_host.$p[index];\n  if (state.value === default_value) {\n    state.value = is_function(value) ? value() : value;\n  }\n  return state;\n}\nfunction on_mount(fn) {\n  if (is_function(fn)) {\n    curr_host.$h.push(fn);\n  }\n}\nfunction event_dispatcher() {\n  let host = curr_host;\n  return (type, detail) => {\n    let event = new CustomEvent(type, { detail, bubbles: false });\n    host.dispatchEvent(event);\n  };\n}\nfunction bind(obj) {\n  assign(curr_host, obj);\n}\nfunction use(node, action, getter) {\n  let ref = getter && computed(getter);\n  let instance = action(node, ref && ref.value);\n  if (!instance) {\n    return;\n  }\n  if (is_function(instance.destroy)) {\n    cleanup(() => instance.destroy());\n  }\n  if (ref && ref.b && is_function(instance.update)) {\n    let init = false;\n    effect(() => {\n      let next = ref.value;\n      if (!init) {\n        init = true;\n        return;\n      }\n      instance.update(next);\n    });\n  }\n}\n\nlet event_name = \"context-request\";\nfunction provide(key, value) {\n  let listener = (event) => {\n    if (event.context === key) {\n      event.stopImmediatePropagation();\n      event.callback(value, null);\n    }\n  };\n  on(curr_host, event_name, listener);\n}\nfunction inject(key, def) {\n  let value = def;\n  let callback = (next, dispose) => {\n    dispose?.();\n    value = next;\n  };\n  let event = new ContextEvent(key, callback, false);\n  curr_host.dispatchEvent(event);\n  return value;\n}\nclass ContextEvent extends Event {\n  constructor(context, callback, multiple) {\n    super(event_name, { bubbles: true, composed: true });\n    this.context = context;\n    this.callback = callback;\n    this.multiple = multiple;\n  }\n}\n\nexport { default_value as A, define as B, ContextEvent as C, css as D, Effect as E, prop as F, bind as G, use as H, html as I, create as J, clone as K, traverse as L, after as M, on as N, toggle as O, attr as P, attr_ifdef as Q, class_toggle as R, Scope as S, style_set as T, get_checked_values as U, VelvetComponent as V, get_select_values as W, set_select_values as X, Signal as a, effect as b, computed as c, batch as d, event_dispatcher as e, untrack as f, peek as g, scope as h, inject as i, cleanup as j, append as k, eval_scope as l, remove_parts as m, is as n, on_mount as o, provide as p, noop as q, replace as r, signal as s, hyphenate as t, use_random_tags as u, assign as v, is_function as w, to_number as x, Computed as y, curr_host as z };\n", "import { k as append, r as replace, b as effect, h as scope, l as eval_scope, s as signal, j as cleanup, d as batch, a as Signal, m as remove_parts, n as is } from './context-2eb14bc3.js';\nexport { y as Computed, C as ContextEvent, E as Effect, S as Scope, a as Signal, V as VelvetComponent, M as after, k as append, v as assign, P as attr, Q as attr_ifdef, d as batch, G as bind, R as class_toggle, j as cleanup, K as clone, c as computed, J as create, D as css, z as curr_host, A as default_value, B as define, b as effect, l as eval_scope, e as event_dispatcher, U as get_checked_values, W as get_select_values, I as html, t as hyphenate, i as inject, n as is, w as is_function, q as noop, N as on, o as on_mount, g as peek, F as prop, p as provide, m as remove_parts, r as replace, h as scope, X as set_select_values, s as signal, T as style_set, x as to_number, O as toggle, L as traverse, f as untrack, H as use, u as use_random_tags } from './context-2eb14bc3.js';\n\nfunction text(marker, expression) {\n  let node = document.createTextNode(\"\");\n  if (marker.nodeType === 1) {\n    append(marker, node);\n  } else {\n    replace(marker, node, false);\n  }\n  effect(() => node.data = expression());\n}\nfunction show(marker, expression) {\n  let instance = scope();\n  let current;\n  let end;\n  effect(() => {\n    let block = expression();\n    if (block === current) {\n      return;\n    }\n    if (end) {\n      instance.clear();\n      destroy_block(marker, end);\n      end = null;\n    }\n    current = block;\n    if (!block) {\n      return;\n    }\n    end = instance.run(() => block(marker));\n  });\n}\nfunction each(marker, block, expression) {\n  let parts = [];\n  let depth = eval_scope.h + 1;\n  effect(() => {\n    let items = expression();\n    let index = 0;\n    let items_len = items.length;\n    let parts_len = parts.length;\n    for (; index < items_len; index++) {\n      if (parts[index]) {\n        let item = parts[index][2];\n        item.value = items[index];\n      } else {\n        let prev = parts[index - 1];\n        let start = prev ? prev[1] : marker;\n        let item = signal(items[index]);\n        let instance = scope(true);\n        instance.h = depth;\n        parts[index] = [instance, instance.run(() => block(start, item, index)), item];\n      }\n    }\n    if (parts_len > items_len) {\n      let prev = parts[index - 1];\n      let start = prev ? prev[1] : marker;\n      let end = parts[parts_len - 1][1];\n      for (; index < parts_len; index++) {\n        parts[index][0].clear();\n      }\n      destroy_block(start, end);\n      parts.length = items_len;\n    }\n  });\n  cleanup(() => {\n    for (let i = 0, l = parts.length; i < l; i++) {\n      let part = parts[i];\n      let instance = part[0];\n      instance.clear();\n    }\n  });\n}\nfunction promise(marker, pending, resolved, rejected, expression) {\n  let status = signal();\n  let result = signal();\n  let error = signal();\n  let curr;\n  let resolved_block = resolved && ((marker2) => resolved(marker2, result));\n  let rejected_block = rejected && ((marker2) => rejected(marker2, error));\n  effect(() => {\n    let key = curr = {};\n    status.value = 1;\n    result.value = null;\n    error.value = null;\n    try {\n      let promise2 = Promise.resolve(expression());\n      promise2.then(\n        (val) => {\n          if (curr === key) {\n            batch(() => {\n              status.value = 2;\n              result.value = val;\n            });\n          }\n        },\n        (err) => {\n          if (curr === key) {\n            batch(() => {\n              status.value = 3;\n              error.value = err;\n            });\n          }\n        }\n      );\n    } catch (err) {\n      status.value = 3;\n      error.value = err;\n    }\n  });\n  show(marker, () => {\n    let current = status.value;\n    return current === 1 ? pending : current === 2 ? resolved_block : current === 3 ? rejected_block : null;\n  });\n}\nfunction keyed(marker, block, expression) {\n  let init;\n  let curr;\n  let end;\n  let instance = scope();\n  effect(() => {\n    let next = expression();\n    if (init && is(next, curr)) {\n      return;\n    }\n    if (end) {\n      instance.clear();\n      destroy_block(marker, end);\n      end = null;\n    }\n    init = true;\n    curr = next;\n    end = instance.run(() => block(marker));\n  });\n}\nfunction dynamic(marker, block, expression) {\n  let host = marker;\n  let instance = scope();\n  let current;\n  effect(() => {\n    let next = expression();\n    if (next === current) {\n      return;\n    }\n    current = next;\n    instance.clear();\n    replace(host, host = next ? instance.run(() => block(next)) : marker, false);\n  });\n}\nfunction subscribe(store) {\n  if (store instanceof Signal) {\n    return store;\n  }\n  let ref = signal();\n  cleanup(store.subscribe((value) => ref.value = value));\n  return ref;\n}\nfunction destroy_block(marker, end) {\n  remove_parts(marker.nextSibling, end);\n}\n\nexport { dynamic, each, keyed, promise, show, subscribe, text };\n", "import {prop, html, clone, traverse, text, after, show, attr, effect, class_toggle, style_set, append, define} from \"@intrnl/velvet/internal\";\nlet template0 = html(\"<div><!></div>\");\nlet template1 = html(\"<span class=label> <!>, <!> </span>\");\nfunction setup($$root, $$host) {\n  let label = prop(0, false);\n  let x = prop(1, 0);\n  let y = prop(2, 0);\n  let big = prop(3, false);\n  let color = prop(4, () => undefined);\n  let fragment0 = clone(template0);\n  let marker2 = traverse(fragment0, [0, 0]);\n  let child1 = traverse(fragment0, [0]);\n  let block1 = $$root => {\n    let fragment1 = clone(template1);\n    let marker0 = traverse(fragment1, [0, 1]);\n    let marker1 = traverse(fragment1, [0, 3]);\n    let child0 = traverse(fragment1, [0]);\n    text(marker0, () => x.value);\n    text(marker1, () => y.value);\n    after($$root, fragment1);\n    return child0;\n  };\n  show(marker2, () => label.value ? block1 : null);\n  attr(child1, \"class\", \"cursor\");\n  effect(() => class_toggle(child1, \"big\", big.value));\n  effect(() => class_toggle(child1, \"label\", label.value));\n  effect(() => style_set(child1, \"border-color\", color.value));\n  effect(() => style_set(child1, \"transform\", `translate(${x.value}px, ${y.value}px) scale(${big.value ? 2 : 1})`));\n  append($$root, fragment0);\n}\nexport default define(\"x-cursor\", setup, {\n  label: 0,\n  x: 1,\n  y: 2,\n  big: 3,\n  color: 4\n}, []);\n", "import {signal, effect, html, clone, traverse, replace, after, each, append, define} from \"@intrnl/velvet/internal\";\nimport {onMount, batch} from '@intrnl/velvet';\nimport Cursor from './Cursor.velvet';\nlet template0 = html(\"<div class=main><x></x></div>\");\nlet template1 = html(\"<x></x>\");\nfunction setup($$root, $$host) {\n  const COUNT = 500;\n  const LOOPS = 6;\n  let x = signal(0);\n  let y = signal(0);\n  let big = signal(false);\n  let counter = signal(0);\n  let stopped = signal(false);\n  let cursors = signal([]);\n  effect(() => {\n    let max = COUNT + Math.round(Math.sin(counter.value / 90 * 2 * Math.PI) * COUNT * 0.5);\n    let next = [];\n    for (let i = max; i--; ) {\n      let f = i / max * LOOPS;\n      let theta = f * 2 * Math.PI;\n      let m = 20 + i * 2;\n      let hue = (f * 255 + counter.value * 10) % 255;\n      next[i] = {\n        color: `hsl(${hue}, 100%, 50%)`,\n        x: x.value + Math.sin(theta) * m | 0,\n        y: y.value + Math.cos(theta) * m | 0\n      };\n    }\n    cursors.value = next;\n  });\n  // The original demo had deferred updates, that really helps a lot because\n  // this event gets spammed a lot when you start moving.\n  const moved = {\n    timeout: false,\n    x: 0,\n    y: 0\n  };\n  function handlePointerMove(ev) {\n    moved.x = ev.x;\n    moved.y = ev.y;\n    if (!moved.timeout) {\n      moved.timeout = true;\n      requestAnimationFrame(() => batch(() => {\n        moved.timeout = false;\n        x.value = moved.x;\n        y.value = moved.y;\n      }));\n    }\n  }\n  function handlePointerDown() {\n    big.value = true;\n  }\n  function handlePointerUp(ev) {\n    big.value = false;\n  }\n  function increment() {\n    if (stopped.value) {\n      return;\n    }\n    counter.value++;\n    requestAnimationFrame(increment);\n  }\n  onMount(() => {\n    window.addEventListener('pointermove', handlePointerMove);\n    window.addEventListener('pointerdown', handlePointerDown);\n    window.addEventListener('pointerup', handlePointerUp);\n    requestAnimationFrame(increment);\n    return () => {\n      window.removeEventListener('pointermove', handlePointerMove);\n      window.removeEventListener('pointerdown', handlePointerDown);\n      window.removeEventListener('pointerup', handlePointerUp);\n      stopped.value = true;\n    };\n  });\n  let fragment0 = clone(template0);\n  let child0 = new Cursor();\n  let marker0 = traverse(fragment0, [0, 0]);\n  let block1 = ($$root, cursor) => {\n    let fragment1 = clone(template1);\n    let child1 = new Cursor();\n    let marker1 = traverse(fragment1, [0]);\n    effect(() => child1[\"color\"] = cursor.value.color);\n    effect(() => child1[\"x\"] = cursor.value.x);\n    effect(() => child1[\"y\"] = cursor.value.y);\n    effect(() => child1[\"big\"] = big.value);\n    replace(marker1, child1, true);\n    after($$root, fragment1);\n    return child1;\n  };\n  $: child0[\"label\"] = true;\n  effect(() => child0[\"x\"] = x.value);\n  effect(() => child0[\"y\"] = y.value);\n  effect(() => child0[\"big\"] = big.value);\n  replace(marker0, child0, true);\n  each(child0, block1, () => cursors.value);\n  append($$root, fragment0);\n}\nexport default define(\"x-spiral\", setup, {}, []);\n", "var MonitorMaxSamples = 100;\nvar MonitorSamplesResult = (function () {\n    function MonitorSamplesResult(min, max, mean, last) {\n        this.min = min;\n        this.max = max;\n        this.mean = mean;\n        this.last = last;\n    }\n    return MonitorSamplesResult;\n}());\n/**\n * Profile Samples.\n */\nvar MonitorSamples = (function () {\n    function MonitorSamples(maxSamples) {\n        this.samples = [];\n        this.maxSamples = maxSamples;\n        this._i = -1;\n    }\n    MonitorSamples.prototype.addSample = function (v) {\n        this._i = (this._i + 1) % this.maxSamples;\n        this.samples[this._i] = v;\n    };\n    MonitorSamples.prototype.each = function (fn) {\n        var samples = this.samples;\n        for (var i = 0; i < samples.length; i++) {\n            fn(samples[(this._i + 1 + i) % samples.length], i);\n        }\n    };\n    MonitorSamples.prototype.calc = function () {\n        var samples = this.samples;\n        if (samples.length === 0) {\n            return new MonitorSamplesResult(0, 0, 0, 0);\n        }\n        var min = samples[(this._i + 1) % samples.length];\n        var max = min;\n        var sum = 0;\n        for (var i = 0; i < samples.length; i++) {\n            var k = samples[(this._i + 1 + i) % samples.length];\n            if (k < min) {\n                min = k;\n            }\n            if (k > max) {\n                max = k;\n            }\n            sum += k;\n        }\n        var last = samples[this._i];\n        var mean = sum / samples.length;\n        return new MonitorSamplesResult(min, max, mean, last);\n    };\n    return MonitorSamples;\n}());\n\n/**\n * Basic Counter.\n */\nvar BasicCounter = (function () {\n    function BasicCounter() {\n        this.value = 0;\n        this.onChange = null;\n    }\n    BasicCounter.prototype.inc = function (value) {\n        if (value > 0) {\n            this.value += value;\n            this.onChange();\n        }\n    };\n    return BasicCounter;\n}());\nvar TimestampedValue = (function () {\n    function TimestampedValue(timestamp, value) {\n        this.value = value;\n        this.next = null;\n    }\n    return TimestampedValue;\n}());\n/**\n * Sliding Counter counts how many times `inc` method were called during `interval` period.\n */\nvar SlidingCounter = (function () {\n    function SlidingCounter(interval) {\n        var _this = this;\n        this._dec = function () {\n            var now = performance.now();\n            while (_this._firstTimestamp !== null) {\n                var nextTimestamp = _this._firstTimestamp;\n                if (now >= nextTimestamp.value) {\n                    _this.value -= nextTimestamp.value;\n                    _this._firstTimestamp = _this._firstTimestamp.next;\n                }\n                else {\n                    setTimeout(_this._dec, Math.ceil(nextTimestamp.value - now));\n                    break;\n                }\n            }\n            if (_this._firstTimestamp === null) {\n                _this._lastTimestamp = null;\n            }\n            _this.onChange();\n        };\n        this.interval = interval;\n        this.value = 0;\n        this.onChange = null;\n        this._firstTimestamp = null;\n        this._lastTimestamp = null;\n    }\n    SlidingCounter.prototype.inc = function (value) {\n        if (value > 0) {\n            var timestamp = new TimestampedValue(performance.now() + this.interval, value);\n            if (this._firstTimestamp === null) {\n                this._firstTimestamp = timestamp;\n                setTimeout(this._dec, this.interval);\n            }\n            else {\n                this._lastTimestamp.next = timestamp;\n            }\n            this._lastTimestamp = timestamp;\n            this.value += value;\n            this.onChange();\n        }\n    };\n    return SlidingCounter;\n}());\n\nvar frameTasks = [];\nvar rafId = -1;\n/**\n * Schedule new task that will be executed on the next frame.\n */\nfunction scheduleNextFrameTask(task) {\n    frameTasks.push(task);\n    if (rafId === -1) {\n        requestAnimationFrame(function (t) {\n            rafId = -1;\n            var tasks = frameTasks;\n            frameTasks = [];\n            for (var i = 0; i < tasks.length; i++) {\n                tasks[i]();\n            }\n        });\n    }\n}\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MonitorGraphHeight = 30;\nvar MonitorGraphWidth = MonitorMaxSamples;\nvar Widget = (function () {\n    function Widget(name) {\n        var _this = this;\n        this._sync = function () {\n            _this.sync();\n            _this._dirty = false;\n        };\n        this.name = name;\n        this.element = document.createElement(\"div\");\n        this.element.style.cssText = \"padding: 2px;\" +\n            \"background-color: #020;\" +\n            \"font-family: monospace;\" +\n            \"font-size: 12px;\" +\n            \"color: #0f0\";\n        this._dirty = false;\n        this.invalidate();\n    }\n    Widget.prototype.invalidate = function () {\n        if (!this._dirty) {\n            this._dirty = true;\n            scheduleNextFrameTask(this._sync);\n        }\n    };\n    Widget.prototype.sync = function () {\n        throw new Error(\"sync method not implemented\");\n    };\n    return Widget;\n}());\nvar MonitorWidgetFlags;\n(function (MonitorWidgetFlags) {\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideMin\"] = 1] = \"HideMin\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideMax\"] = 2] = \"HideMax\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideMean\"] = 4] = \"HideMean\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideLast\"] = 8] = \"HideLast\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideGraph\"] = 16] = \"HideGraph\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"RoundValues\"] = 32] = \"RoundValues\";\n})(MonitorWidgetFlags || (MonitorWidgetFlags = {}));\nvar MonitorWidget = (function (_super) {\n    __extends(MonitorWidget, _super);\n    function MonitorWidget(name, flags, unitName, samples) {\n        var _this = _super.call(this, name) || this;\n        _this.flags = flags;\n        _this.unitName = unitName;\n        _this.samples = samples;\n        var label = document.createElement(\"div\");\n        label.style.cssText = \"text-align: center\";\n        label.textContent = _this.name;\n        var text = document.createElement(\"div\");\n        if ((flags & MonitorWidgetFlags.HideMin) === 0) {\n            _this.minText = document.createElement(\"div\");\n            text.appendChild(_this.minText);\n        }\n        else {\n            _this.minText = null;\n        }\n        if ((flags & MonitorWidgetFlags.HideMax) === 0) {\n            _this.maxText = document.createElement(\"div\");\n            text.appendChild(_this.maxText);\n        }\n        else {\n            _this.maxText = null;\n        }\n        if ((flags & MonitorWidgetFlags.HideMean) === 0) {\n            _this.meanText = document.createElement(\"div\");\n            text.appendChild(_this.meanText);\n        }\n        else {\n            _this.meanText = null;\n        }\n        if ((flags & MonitorWidgetFlags.HideLast) === 0) {\n            _this.lastText = document.createElement(\"div\");\n            text.appendChild(_this.lastText);\n        }\n        else {\n            _this.lastText = null;\n        }\n        _this.element.appendChild(label);\n        _this.element.appendChild(text);\n        if ((flags & MonitorWidgetFlags.HideGraph) === 0) {\n            _this.canvas = document.createElement(\"canvas\");\n            _this.canvas.style.cssText = \"display: block; padding: 0; margin: 0\";\n            _this.canvas.width = MonitorGraphWidth;\n            _this.canvas.height = MonitorGraphHeight;\n            _this.ctx = _this.canvas.getContext(\"2d\");\n            _this.element.appendChild(_this.canvas);\n        }\n        else {\n            _this.canvas = null;\n            _this.ctx = null;\n        }\n        return _this;\n    }\n    MonitorWidget.prototype.sync = function () {\n        var _this = this;\n        var result = this.samples.calc();\n        var scale = MonitorGraphHeight / (result.max * 1.2);\n        var min;\n        var max;\n        var mean;\n        var last;\n        if ((this.flags & MonitorWidgetFlags.RoundValues) === 0) {\n            min = result.min.toFixed(2);\n            max = result.max.toFixed(2);\n            mean = result.mean.toFixed(2);\n            last = result.last.toFixed(2);\n        }\n        else {\n            min = Math.round(result.min).toString();\n            max = Math.round(result.max).toString();\n            mean = Math.round(result.mean).toString();\n            last = Math.round(result.last).toString();\n        }\n        if (this.minText !== null) {\n            this.minText.textContent = \"min: \\u00A0\" + min + this.unitName;\n        }\n        if (this.maxText !== null) {\n            this.maxText.textContent = \"max: \\u00A0\" + max + this.unitName;\n        }\n        if (this.meanText !== null) {\n            this.meanText.textContent = \"mean: \" + mean + this.unitName;\n        }\n        if (this.lastText !== null) {\n            this.lastText.textContent = \"last: \" + last + this.unitName;\n        }\n        if (this.ctx !== null) {\n            this.ctx.fillStyle = \"#010\";\n            this.ctx.fillRect(0, 0, MonitorGraphWidth, MonitorGraphHeight);\n            this.ctx.fillStyle = \"#0f0\";\n            this.samples.each(function (v, i) {\n                _this.ctx.fillRect(i, MonitorGraphHeight, 1, -(v * scale));\n            });\n        }\n    };\n    return MonitorWidget;\n}(Widget));\nvar CounterWidget = (function (_super) {\n    __extends(CounterWidget, _super);\n    function CounterWidget(name, counter) {\n        var _this = _super.call(this, name) || this;\n        _this.counter = counter;\n        _this.text = document.createElement(\"div\");\n        _this.element.appendChild(_this.text);\n        return _this;\n    }\n    CounterWidget.prototype.sync = function () {\n        this.text.textContent = this.name + \": \" + this.counter.value;\n    };\n    return CounterWidget;\n}(Widget));\n\nvar container = null;\nvar initialized = false;\n/**\n * Initialize Performance Monitor.\n */\nfunction initPerfMonitor(options) {\n    if (!initialized) {\n        if (options.container) {\n            container = options.container;\n        }\n        initialized = true;\n    }\n}\n/**\n * Check that everything is properly initialized.\n */\nfunction checkInit() {\n    if (!container) {\n        container = document.createElement(\"div\");\n        container.style.cssText = \"position: fixed;\" +\n            \"opacity: 0.9;\" +\n            \"right: 0;\" +\n            \"bottom: 0\";\n        document.body.appendChild(container);\n    }\n    initialized = true;\n}\n/**\n * Start FPS monitor\n */\nfunction startFPSMonitor(flags) {\n    if (flags === void 0) { flags = MonitorWidgetFlags.HideMin | MonitorWidgetFlags.HideMax |\n        MonitorWidgetFlags.HideMean | MonitorWidgetFlags.RoundValues; }\n    checkInit();\n    var data = new MonitorSamples(MonitorMaxSamples);\n    var w = new MonitorWidget(\"FPS\", flags, \"\", data);\n    container.appendChild(w.element);\n    var alpha = 2 / 121;\n    var last = 0;\n    var fps = 60;\n    function update(now) {\n        if (last > 0) {\n            fps += alpha * ((1000 / (now - last)) - fps);\n        }\n        last = now;\n        data.addSample(fps);\n        w.invalidate();\n        requestAnimationFrame(update);\n    }\n    requestAnimationFrame(update);\n}\n/**\n * Start Memory Monitor\n */\nfunction startMemMonitor(flags) {\n    if (flags === void 0) { flags = MonitorWidgetFlags.HideMin | MonitorWidgetFlags.HideMean; }\n    checkInit();\n    if (performance.memory === undefined) {\n        return;\n    }\n    var data = new MonitorSamples(MonitorMaxSamples);\n    var w = new MonitorWidget(\"Memory\", flags, \"MB\", data);\n    container.appendChild(w.element);\n    function update() {\n        data.addSample(Math.round(performance.memory.usedJSHeapSize / (1024 * 1024)));\n        w.invalidate();\n        setTimeout(update, 30);\n    }\n    update();\n}\nvar ProfilerDetails = (function () {\n    function ProfilerDetails(name, unitName, flags) {\n        this.data = new MonitorSamples(MonitorMaxSamples);\n        this.widget = new MonitorWidget(name, flags, unitName, this.data);\n        this.startTime = -1;\n    }\n    return ProfilerDetails;\n}());\nvar profilerInstances = {};\nvar CounterDetails = (function () {\n    function CounterDetails(name, interval) {\n        var _this = this;\n        this.data = interval === undefined ? new BasicCounter() : new SlidingCounter(interval);\n        this.widget = new CounterWidget(name, this.data);\n        this.data.onChange = function () {\n            _this.widget.invalidate();\n        };\n    }\n    return CounterDetails;\n}());\nvar counterInstances = {};\n/**\n * Initialize profiler and insert into container.\n */\nfunction initProfiler(name, flags) {\n    if (flags === void 0) { flags = 0; }\n    checkInit();\n    var profiler = profilerInstances[name];\n    if (profiler === void 0) {\n        profilerInstances[name] = profiler = new ProfilerDetails(name, \"ms\", flags);\n        container.appendChild(profiler.widget.element);\n    }\n}\n/**\n * Initialize counter and insert into container.\n */\nfunction initCounter(name, interval) {\n    checkInit();\n    var counter = counterInstances[name];\n    if (counter === void 0) {\n        counterInstances[name] = counter = new CounterDetails(name, interval);\n        container.appendChild(counter.widget.element);\n    }\n}\nfunction startProfile(name) {\n    var profiler = profilerInstances[name];\n    if (profiler !== void 0) {\n        profiler.startTime = performance.now();\n    }\n}\nfunction endProfile(name) {\n    var now = performance.now();\n    var profiler = profilerInstances[name];\n    if (profiler !== void 0 && profiler.startTime !== -1) {\n        profiler.data.addSample(now - profiler.startTime);\n        profiler.widget.invalidate();\n    }\n}\nfunction count(name, value) {\n    if (value === void 0) { value = 1; }\n    var counter = counterInstances[name];\n    if (counter !== void 0) {\n        counter.data.inc(value);\n    }\n}\n/**\n * lookup a profile by name\n * @param name the name of the profile to lookup\n */\nfunction getProfile(name) {\n    return profilerInstances[name];\n}\n/**\n * lookup a counter by name\n * @param name the name of the counter to lookup\n */\nfunction getCounter(name) {\n    return counterInstances[name];\n}\n\nexport { initPerfMonitor, startFPSMonitor, startMemMonitor, ProfilerDetails, CounterDetails, initProfiler, initCounter, startProfile, endProfile, count, getProfile, getCounter, MonitorSamplesResult, MonitorMaxSamples, MonitorSamples, BasicCounter, SlidingCounter, Widget, MonitorWidgetFlags, MonitorWidget, CounterWidget };\n", "import Spiral from './components/Spiral.velvet';\nimport Cursor from './components/Cursor.velvet';\n\nimport * as perfmon from 'perf-monitor';\n\nimport './style.css';\n\n\npatchComponent(Spiral);\npatchComponent(Cursor);\n\nif (!(/[&?]perfmon=(false|off|0)\\b/).test(location.search)) {\n\tperfmon.startFPSMonitor();\n\tperfmon.startMemMonitor();\n}\n\nconst spiral = new Spiral();\ndocument.body.appendChild(spiral);\n\n\nfunction patchComponent (Component) {\n\t// we don't want shadow DOM to be in our way here, make Velvet think we\n\t// already have a shadow root in place.\n\tComponent.prototype.attachShadow = function () {\n\t\tif (!this.shadowRoot) {\n\t\t\tObject.defineProperty(this, 'shadowRoot', { value: this })\n\t\t}\n\n\t\treturn this;\n\t};\n}\n"],
  "mappings": "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",
  "names": ["html", "fragment", "is_wrapped", "node", "content", "wrapper", "children", "len", "clone", "template", "traverse", "node", "indices", "ref", "il", "x", "j", "replace", "adopt", "children", "len", "append", "after", "remove_parts", "a", "b", "curr", "attr", "node", "name", "value", "class_toggle", "node", "name", "value", "style_set", "_Object", "_Symbol", "RE_HYPHENATE", "hyphenate", "str", "RE_HYPHENATE", "is", "_Object", "assign", "is_function", "x", "undefined$1", "RUNNING", "STALE", "NOTIFIED", "HAS_ERROR", "SHOULD_SUBSCRIBE", "SUBSCRIBED", "eval_scope", "eval_context", "batched_effects", "batch_depth", "batch_iteration", "global_version", "start_batch", "end_batch", "error", "has_error", "effects", "a", "b", "effect2", "err", "get_value", "signal2", "node", "head", "prev", "next", "prepare_sources", "target", "node", "rollback", "STALE", "cleanup_sources", "sources", "next", "undefined$1", "end_effect", "prev_context", "_this", "eval_context", "end_batch", "RUNNING", "Signal", "value", "SUBSCRIBED", "prev", "fn", "signal2", "effect", "get_value", "batch_iteration", "global_version", "start_batch", "Effect", "compute", "undefined$1", "SHOULD_SUBSCRIBE", "_this", "RUNNING", "finish", "prev_context", "eval_context", "start_batch", "prepare_sources", "end_effect", "NOTIFIED", "batched_effects", "node", "Scope", "detached", "eval_scope", "callback", "prev_scope", "scopes", "cleanups", "scope2", "cleanup2", "scope", "cleanup", "is_function", "batch", "batch_depth", "end_batch", "signal", "value", "Signal", "effect", "compute", "effect2", "Effect", "dispose", "error", "eval_scope", "ENABLE_RANDOM_TAGS", "RANDOM_TAG", "curr_host", "default_value", "_Symbol", "VelvetComponent", "scope", "host", "props", "definition", "prop2", "index", "signal", "setup", "styles", "instance", "hooks", "root", "init_ccss", "prev_host", "style", "append", "hook", "ret", "is_function", "attr", "prev", "next", "mapping", "define", "tag", "observed_attrs", "attr_to_prop", "_Object", "Component", "hyphen", "hyphenate", "ENABLE_RANDOM_TAGS", "RANDOM_TAG", "prop", "index", "value", "state", "curr_host", "default_value", "is_function", "on_mount", "fn", "text", "marker", "expression", "node", "append", "replace", "effect", "show", "instance", "scope", "current", "end", "block", "destroy_block", "each", "parts", "depth", "eval_scope", "items", "index", "items_len", "parts_len", "item", "prev", "start", "signal", "cleanup", "i", "l", "destroy_block", "marker", "end", "remove_parts", "template0", "html", "template1", "setup", "$$root", "$$host", "label", "prop", "x", "y", "big", "color", "fragment0", "clone", "marker2", "traverse", "child1", "block1", "fragment1", "marker0", "marker1", "child0", "text", "after", "show", "attr", "effect", "class_toggle", "style_set", "append", "Cursor_default", "define", "template0", "html", "template1", "setup", "$$root", "$$host", "x", "signal", "y", "big", "counter", "stopped", "cursors", "effect", "max", "next", "i", "f", "theta", "m", "hue", "moved", "handlePointerMove", "ev", "batch", "handlePointerDown", "handlePointerUp", "increment", "on_mount", "fragment0", "clone", "child0", "Cursor_default", "marker0", "traverse", "block1", "cursor", "fragment1", "child1", "marker1", "replace", "after", "$", "each", "append", "Spiral_default", "define", "MonitorMaxSamples", "MonitorSamplesResult", "min", "max", "mean", "last", "MonitorSamples", "maxSamples", "v", "fn", "samples", "sum", "i", "k", "BasicCounter", "value", "TimestampedValue", "timestamp", "SlidingCounter", "interval", "_this", "now", "nextTimestamp", "frameTasks", "rafId", "scheduleNextFrameTask", "task", "t", "tasks", "__extends", "extendStatics", "d", "b", "p", "__", "MonitorGraphHeight", "MonitorGraphWidth", "Widget", "name", "MonitorWidgetFlags", "MonitorWidget", "_super", "flags", "unitName", "label", "text", "result", "scale", "CounterWidget", "counter", "container", "initialized", "checkInit", "container", "initialized", "startFPSMonitor", "flags", "MonitorWidgetFlags", "data", "MonitorSamples", "MonitorMaxSamples", "w", "MonitorWidget", "alpha", "last", "fps", "update", "now", "startMemMonitor", "ProfilerDetails", "name", "unitName", "CounterDetails", "name", "interval", "_this", "BasicCounter", "SlidingCounter", "CounterWidget", "patchComponent", "Spiral_default", "Cursor_default", "startFPSMonitor", "startMemMonitor", "spiral", "Component"]
}
